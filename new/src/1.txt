/*
 * main.cpp
 *
 * Author: Wongky
 * Copyright (c) 2018-2019 HKUST SmartCar Team
 * Refer to LICENSE for details
 */

//#include <cassert>
//#include <cstring>
//#include <libbase/k60/mcg.h>
//#include <libsc/system.h>
//
//#include <stdlib.h>
//#include <libsc/led.h>
//#include <cmath>
//
////#include "pid.h"
//#include "function.h"
//#include "var.h"
////#include "Coor.h"
//#include "config.h"
//#include "image_processing.h"


#include <cassert>
#include <cstring>
#include <stdlib.h>
#include <string>
#include <libbase/k60/mcg.h>
#include <libsc/system.h>
#include "libsc/joystick.h"
#include "libsc/battery_meter.h"
#include "libbase/misc_utils_c.h"
#include "image_processing.h"
#include "libutil/misc.h"
#include "config.h"
#include "var.h"

#include <stdlib.h>
#include <cmath>




namespace libbase
{
	namespace k60
	{

		Mcg::Config Mcg::GetMcgConfig()
		{
			Mcg::Config config;
			config.external_oscillator_khz = 50000;
			config.core_clock_khz = 100000;
			return config;
		}

	}
}

using libsc::System;
using namespace libsc;
using namespace libbase::k60;

//pos
const uint8_t COUNT_PER_CM = 23;
const float CM_PER_COUNT = 1/COUNT_PER_CM;  //0.041666666
const float PI = 22/7;
const float DEG_PER_RAD = 180/PI; //1 rad = 180¢X/£k
const uint8_t WHEEL_DIST = 12;
const uint8_t Y_CENTER_OFFEST = 12;
const int16_t CARX = 189/2;
const int16_t CARY = 120/2 + Y_CENTER_OFFEST;
const int16_t CARW = 16; //cm
const int16_t XCOOR_IMAGE_OFFSET = 189/2; //lowest middle of image is (0,0)
const int16_t O_X_LEFT = 60;
const int16_t O_X_RIGHT = 150;
const float X_CM_PER_PIX = 0.1; //1pixel = 1mm, x-axis
const float Y_CM_PER_PIX = 2;
const int8_t YX_ratio = 20; //20mm/1mm
int32_t aCountL = 0;
int32_t aCountR = 0;

bool printLCD = true;

float BeaconAvoidAngleCalculate(const uint16_t& bx, const uint16_t& by);
inline void setAnglePower(const float& radAngle);

int main(void)
{
	System::Init();
//init///////////////////////////////////
//	//led
//	Led::Config led_config;
//	led_config.is_active_low = true;
//    led_config.id = 0;
//    Led Led0(led_config);
//    led0 = &Led0;
//    led_config.id = 1;
//    Led Led1(led_config);
//    led1 = &Led1;
//
//    //battery
//	BatteryMeter::Config bConfig;
//	bConfig.voltage_ratio = 0.4;
//	BatteryMeter bMeter_(bConfig);
//	bMeter = &bMeter_;
//
//    //lcd
//	St7735r::Config lcd_config;
//	lcd_config.orientation = 1;
//	lcd_config.fps = 60;
//	St7735r lcd_(lcd_config);
//	lcd = &lcd_;
//	lcd->SetRegion(Lcd::Rect(0, 0, 160, 128));
//	lcd->Clear(Lcd::kWhite);
//	LcdTypewriter::Config writer_config;
//	writer_config.lcd = lcd;
//	LcdTypewriter writer_(writer_config);
//	writer = &writer_;
//
//    //motor
//	AlternateMotor::Config motor_config;
//	motor_config.id = 0;
//	AlternateMotor motor0(motor_config);
//	L_motor = &motor0;
//	motor_config.id = 1;
//	AlternateMotor motor1(motor_config);
//	R_motor = &motor1;
//	//encoder
//	DirEncoder::Config encoder_config;
//	encoder_config.id = 1;
//	DirEncoder encoder1_(encoder_config);
//	encoder1 = &encoder1_;
//	encoder_config.id = 0;
//	DirEncoder encoder2_(encoder_config);
//	encoder2 = &encoder2_;
//    //pid
//	PID L_pid_(L_kp, L_ki, L_kd, 1000, -1000);
//	L_pid = &L_pid_;
//	L_pid->errorSumBound = 10000;
//	PID R_pid_(R_kp, R_ki, R_kd, 1000, -1000);
//	R_pid = &R_pid_;
//	R_pid->errorSumBound = 10000;
//
//	Ov7725::Config cam_config;
//	cam_config.id = 0;
//	cam_config.w = width;
//	cam_config.h = height;
//	cam_config.contrast = contrast;
//	cam_config.brightness = brightness;
//	cam_config.fps = k60::Ov7725Configurator::Config::Fps::kHigh;
//	k60::Ov7725 cam_(cam_config);
//	cam = &cam_;
//	cam->Start();
//
//	//uart
//	JyMcuBt106::Config uart_config;
//	uart_config.baud_rate = libbase::k60::Uart::Config::BaudRate::k115200;
//	uart_config.id = 0;
//	uart_config.rx_isr = &bt_listener;
//	JyMcuBt106 bt_(uart_config);
//	bt = &bt_;
//	uart_config.baud_rate = libbase::k60::Uart::Config::BaudRate::k9600;
//	uart_config.id = 2;
//	uart_config.rx_isr = &comm_listener;
//	JyMcuBt106 comm_(uart_config);
//	comm = &comm_;

	//joystick
//	Joystick::Config j_config;
//	j_config.id = 0;
//	Joystick joyStick(j_config);
////////////////////////////////////////////

//init/////////////////////////////////////
	Led Led0(init_led(0));
	led0 = &Led0;
	Led Led1(init_led(1));
	led1 = &Led1;
	BatteryMeter bMeter_(init_bMeter());
	bMeter = &bMeter_;
	St7735r lcd_(init_lcd());
	lcd = &lcd_;
	lcd->SetRegion(Lcd::Rect(0, 0, 160, 128));
	lcd->Clear(Lcd::kWhite);
	LcdTypewriter writer_(init_writer());
	writer = &writer_;
	AlternateMotor motor0(init_motor(0));
	L_motor = &motor0;
	AlternateMotor motor1(init_motor(1));
	R_motor = &motor1;
	DirEncoder encoder1_(init_encoder(1));
	encoder1 = &encoder1_;
	DirEncoder encoder2_(init_encoder(0));
	encoder2 = &encoder2_;
	k60::Ov7725 cam_(init_cam());
	cam = &cam_;
	cam->Start();
	Joystick::Config j_config;
	j_config.id = 0;
	Joystick joyStick(j_config);
	uint8_t state = 100;
	JyMcuBt106 bt_(init_bt());
	bt = &bt_;
	JyMcuBt106 comm_(init_comm());
	comm = &comm_;

	PID L_pid_(L_kp, L_ki, L_kd, 1000, -1000);
	L_pid = &L_pid_;
	L_pid->errorSumBound = 100000;
	PID R_pid_(R_kp, R_ki, R_kd, 1000, -1000);
	R_pid = &R_pid_;
	R_pid->errorSumBound = 100000;

	PID Dir_pid_(Dir_kp, Dir_ki, Dir_kd, 500, -500);
	Dir_pid = &Dir_pid_;
	Dir_pid->errorSumBound = 10000;
	PID avoid_pid_(avoid_kp, avoid_ki, avoid_kd, 500, -500);
	avoid_pid = &avoid_pid_;
	avoid_pid->errorSumBound = 10000;
////////////////////////////////////////////

//var////////////////////////////////////////


	//pid
	int32_t L_count = 0;
	int32_t R_count = 0;
//	bool posCal = false;
//	Coor currentPos(0,0);

	//time
    uint32_t process_time = 0;
    uint32_t past_time = System::Time();
    uint32_t pid_time = 0;
    run = false;
/////////////////////////////////////////

	L_pid->settarget(chasing_speed);
	R_pid->settarget(chasing_speed);

	display_bMeter();


	while (true){
		if (tick != System::Time() && run) {
			tick = System::Time();
//pid////////////////////////////
			if (tick - pid_time >= 10) {
				uint32_t time_diff = tick - pid_time;
				encoder1->Update();
				encoder2->Update();
				L_count = encoder1->GetCount() * 50 / (int) time_diff;
				R_count = encoder2->GetCount() * 50 / (int) time_diff;
				SetPower(L_pid->output(L_count), 0);
				SetPower(R_pid->output(-R_count), 1);
				pid_time = System::Time();

//				if(posCal)
//				{
//					aCountL = L_count;
//					aCountR = R_count;
//
//					if(Timer::TimeDiff(System::Time(),past_time)>=500)
//					{
//						//MotorPositionCalculate(currentPos);
//						if(printLCD)
//						{
//							char temp[20] = { };
//							sprintf(temp, "time%d", past_time);
//							lcd->SetRegion(Lcd::Rect(0, 60, 128, 160));
//							writer->WriteString(temp);
//							sprintf(temp, "x:%.2f/ty:%.2f", currentPos.x,currentPos.y);
//							lcd->SetRegion(Lcd::Rect(0, 80, 128, 160));
//							writer->WriteString(temp);
//							sprintf(temp, "theta:%.2f", currentPos.theta);
//							lcd->SetRegion(Lcd::Rect(0, 100, 128, 160));
//							writer->WriteString(temp);
//						}
//						past_time = System::Time();
//					}
//				}

			}
///////////////////////////////////

//avoid///////////////////////////
			if (tick - process_time >= 30) {
							process_time = tick;
							if (tick - o_target.received_time < 100) {
								uint16_t x = o_target.target->center.first;
								uint16_t y = o_target.target->center.second;
								if(printLCD)
								{
									char temp[20] = { };
									sprintf(temp, "x=%d y=%d", x,y);
									lcd->SetRegion(Lcd::Rect(0, 40, 128, 160));
									writer->WriteString(temp);
								}
								if ( x > O_X_LEFT && x < O_X_RIGHT)
								{

									if (y> 70)
										action = backward;
									else
									{
										action = avoid;
										setAnglePower(BeaconAvoidAngleCalculate(x, y));
									}
									//								FSM();
									//								continue;
								}
							}
			}
/////////////////////////////////////
			if(tick - past_time >=15000){
				SetPower(0, 0);
				SetPower(0, 1);
				run = false;
			}
		}



	}

	return 0;
}

//uint32_t distanceSquare(const Coor& a, const Coor& b)
//{
//	return (a.x -b.x) *(a.x -b.x) + (a.y -b.y) *(a.y -b.y);
//}
//
////cm coor
////relative position of the wheels centerpoint c at instant i. //p.20
//Coor MotorPositionCalculate(Coor& currentPosition)
//{
//	Coor positionChange;
//
//	float Ldist = (float)(aCountL * CM_PER_COUNT);
//	float Rdist = (float)(aCountR * CM_PER_COUNT);
//	float Cdist = (Rdist+Ldist)/2;
//
//	//not st.line
//	if (aCountL != aCountR)
//	{
//		positionChange.theta = (Rdist-Ldist)/WHEEL_DIST;
//		//currentPosition.theta += (Rdist-Ldist)/WHEEL_DIST;
//		currentPosition.theta += positionChange.theta;
//		currentPosition.Simplfytheta();
//		positionChange.Simplfytheta();
//	}
//
//    float cosTheta = cos(currentPosition.theta);
//    float sinTheta = sin(currentPosition.theta);
//
//    positionChange.x = Cdist * cosTheta;
//    positionChange.y = Cdist * sinTheta;
////	currentPosition.x += Cdist * cosTheta;
////	currentPosition.y += Cdist * sinTheta;
//	currentPosition.x += positionChange.x;
//	currentPosition.y += positionChange.y;
//
//	return positionChange;
//
//}

float BeaconAvoidAngleCalculate(const uint16_t& bx, const uint16_t& by)
{
	if(bx<=O_X_LEFT||bx>=O_X_RIGHT)return 0.0;
	//assume beacon position need to avoid

	int16_t dx = bx - CARX;
	int16_t dy = -(by - CARY); //lower pixel is larger
	uint32_t hyp = (dx *dx + dy *dy) ;
	//int16_t dy = -(by - CARY) * YX_ratio; //lower pixel is larger
	//uint32_t hyp = (CARX -bx) *(CARX -bx) + (CARY -by) * YX_ratio *(CARY -by) * YX_ratio;

	//float targetAngle = 0; //rad coor
	float Radius = 0.0; //pixel coor;-ve turn left; +ve turn right

	//have dist
	if (hyp != 0)
	{
		//st line
		if (dx == 0)
		{
			//front
			if (dy > 0)
			{
				//turn left
				int16_t ndx=CARX-O_X_LEFT;
				//targetAngle = - atan(ndx/dy);
				Radius = - (float) (sqrt(ndx*ndx + dy*dy));

			}
			//back
//			else //dy<=0
//			{
//				targetAngle = 0.0;
//				Radius = 0.0;
//			}
		}
		else  //dx != 0
		{
			if (dy == 0)
			{
				//beacon at right
				if (dx > 0)
				{
					//turn left
					//targetAngle = - PI/2;
					//Radius = 0.0;
					//backward
				}
				//beacon at left
				else  //dx < 0
				{
					//turn right
					//targetAngle = PI/2;
					//Radius = 0.0;
					//backward
				}
			}
			else if (dx > 0)
			{
				//beacon at front right
				if (dy > 0)
				{
					//turn left
					int16_t ndx=O_X_RIGHT-bx;
					//targetAngle = - atan(ndx/dy);
					Radius = - (float) (sqrt(ndx*ndx + dy*dy));
				}
				//beacon at back right
//				else //dy<0
//				{
//					targetAngle = 0.0;
//					Radius = 0.0;
//				}
			} else //dx<0
			{
				//beacon at front left
				if (dy > 0)
				{
					//turn right
					int16_t ndx=bx-O_X_LEFT;
					//targetAngle = atan(ndx/dy);
					Radius = (float) (sqrt(ndx*ndx + dy*dy));
				}
				//beacon at back left
//				else //dy<0
//				{
//					targetAngle = 0.0;
//					Radius = 0.0;
//				}
			}
		}
	}

	if(printLCD)
	{
		char temp[20] = { };
		sprintf(temp, "r=%.1f hyp=%d", Radius,hyp);
		lcd->SetRegion(Lcd::Rect(0, 60, 128, 160));
		writer->WriteString(temp);
		sprintf(temp, "dx=%d, dy=%d",dx,dy);
		lcd->SetRegion(Lcd::Rect(0, 80, 128, 160));
		writer->WriteString(temp);
	}

	//return targetAngle;
	return Radius;

}

//void setAnglePower(const float& radAngle)
//{
//	if(radAngle>90||radAngle<-90||radAngle==0)return;
//
//	float diff = (abs(radAngle) * (CARW*COUNT_PER_CM))/2;
//	if(printLCD)
//	{
//		char temp[20] = { };
//		sprintf(temp, "d=%.1f",diff);
//		lcd->SetRegion(Lcd::Rect(0, 70, 128, 160));
//		writer->WriteString(temp);
//	}
//
//	//	-ve turn left; +ve turn right
//	if(radAngle<0)
//	{
//		L_pid->settarget(chasing_speed - diff);
//		R_pid->settarget(chasing_speed + diff);
//	}
//	else //radAngle>0
//	{
//		L_pid->settarget(chasing_speed + diff);
//		R_pid->settarget(chasing_speed - diff);
//	}
//}

void setAnglePower(const float& radAngle)
{

	float diff = ((abs(radAngle)-9) / (abs(radAngle)+9));
	if(printLCD)
	{
		char temp[20] = { };
		sprintf(temp, "d=%.4f",diff);
		lcd->SetRegion(Lcd::Rect(0, 100, 128, 160));
		writer->WriteString(temp);
	}

	//	-ve turn left; +ve turn right
	if(radAngle<0)
	{
		R_pid->settarget(chasing_speed);
		L_pid->settarget(chasing_speed * diff);
	}
	else //radAngle>0
	{
		L_pid->settarget(chasing_speed);
		R_pid->settarget(chasing_speed * diff);
	}
}

//int16_t toOrigin(int16_t x)
//{
//	if(x==XCOOR_IMAGE_OFFSET)
//	{
//		x = 0;
//	}
//	else if(x>XCOOR_IMAGE_OFFSET)
//	{
//		x = x - XCOOR_IMAGE_OFFSET;
//	}
//	else //beaconLastPos.x<XCOOR_IMAGE_OFFSET
//	{
//		x = - (x);
//	}
//
//	return x;
//}
//
////pixel coor
//float BeaconAvoidAngleCalculate(Coor& beacon)
//{
//	int16_t dx = beacon.x - CARX;
//	int16_t dy = beacon.y - CARY;
//	uint32_t hyp = distanceSquare(Coor(CARX,CARY), beacon);
//
//	float targetAngle = 0.0;
//
//	//have dist
//	if (hyp != 0)
//	{
//		//st line
//		if (dx == 0)
//		{
//			//front
//			if (dy > 0)
//			{
//				targetAngle = 179.999999999;
//			} else //dy<=0
//			{
//				targetAngle = 0.0;
//			}
//		} else //dx != 0
//		{
//			float sinTheta = dx / sqrt(hyp);
//			if (dy == 0)
//			{
//				//beacon at right
//				if (dx > 0)
//				{
//					targetAngle = -90.0;
//				} else //beacon at left
//				{
//					targetAngle = 90.0;
//				}
//			} else if (dx > 0)
//			{
//				//beacon at front right
//				if (dy > 0)
//				{
//					targetAngle = asin(sinTheta);
//					targetAngle = targetAngle * DEG_PER_RAD;
//					targetAngle = -180 + targetAngle;
//				}
////				else //dy<0
////				{
////					targetAngle = asin(sinTheta);
////					targetAngle = targetAngle * DEG_PER_RAD;
////					targetAngle = -targetAngle;
////				}
//			} else //dx<0
//			{
//				//beacon at front left
//				if (dy > 0)
//				{
//					targetAngle = asin(-sinTheta);
//					targetAngle = targetAngle * DEG_PER_RAD;
//					targetAngle = 180 - targetAngle;
//				}
////				else //dy<0
////				{
////					targetAngle = asin(-sinTheta);
////					targetAngle = targetAngle * DEG_PER_RAD;
////				}
//			}
//		}
//	}
//
//	return targetAngle;
//}
//
////cm coor
//Coor BeaconPositionPrediction(const Coor& beaconLastPos, const Coor& carPosChange)
//{
//	Coor BeaconPosInCM;
//
//	if(beaconLastPos.x==XCOOR_IMAGE_OFFSET)
//	{
//		BeaconPosInCM.x = 0;
//	}
//	else if(beaconLastPos.x>XCOOR_IMAGE_OFFSET)
//	{
//		BeaconPosInCM.x = beaconLastPos.x - XCOOR_IMAGE_OFFSET;
//	}
//	else //beaconLastPos.x<XCOOR_IMAGE_OFFSET
//	{
//		BeaconPosInCM.x = - (XCOOR_IMAGE_OFFSET-beaconLastPos.x);
//	}
//
//	//multiply sth to cm
//	//.....//
//
//	BeaconPosInCM.y = beaconLastPos.x; //......multiply sth to cm
//
//	BeaconPosInCM.x -= carPosChange.x;
//	BeaconPosInCM.y -= carPosChange.y;
//
//	return BeaconPosInCM;
//}


